{"ast":null,"code":"/**\n * WordDistribution.jsx\n * \n * Purpose: Implementation of grid and question word\n *          The game dynamically updates based on the selected month, providing audio feedback\n *          and visual rewards. Users earn stars for correct matches and can reset the game.\n * \n * Author(s): Preksha Joon, Aaron Gonsalves\n * Assisted by: ChatGPT (Documentation assistance + Fixing Roadblocks)\n * \n * COTS Used:\n * - React: JavaScript library for building user interfaces. (https://reactjs.org/)\n * - Tailwind CSS: Utility-first CSS framework for styling. (https://tailwindcss.com/)\n * - Local assets for images (Michael's efforts and Microsoft Designer) and audio files.\n */import React,{useEffect,useState,useCallback}from\"react\";import{WORD_INFO}from\"../WordBank\";import MobileView from\"./MobileView\";import DesktopView from\"./DesktopView\";import tryAgainAudio from\"../audio/tryagain.mp3\";import congratulationsAudio from\"../audio/congratulatory.mp3\";import inactivePanel from\"../images/colour.jpg\";/**\n * WordDistribution Component\n * \n * Purpose: Renders the game interface where users match words to images based on the selected month.\n * \n * Parameters:\n * - month: (number) The selected number corresponding to the month based on the words of the month, \n * which determines the set of words and game logic.\n */import{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";function WordDistribution(_ref){let{month}=_ref;const[callCount,setCallCount]=useState(0);const[boxes,setBoxes]=useState([]);const[initWords,setInitWords]=useState([]);const[isInitialized,setIsInitialized]=useState(false);const[displayText,setDisplayText]=useState(\"\");const[displayAudio,setDisplayAudio]=useState(\"\");const[displayImage,setDisplayImage]=useState(\"\");const[roundDisplay,setRoundDisplay]=useState(callCount+\"/\"+month);const[successCount,setSuccessCount]=useState(0);const[gameEnd,setGameEnd]=useState(false);/**\n   * gameOver\n   * \n   * Purpose: Determines if the game has ended based on the number of rounds played.\n   */const GameOver=useCallback(()=>{if(month<9){if(month===3&&callCount===3||month===6&&callCount===6){setGameEnd(true);}}else{if(callCount===month)setGameEnd(true);}},[month,callCount]);/**\n   * generateWordArray\n   * \n   * Purpose: Generates a new word array for the grid, shuffling words and preparing the game state for the next round. \n   * Also, selects the question word for each round, and updates it on display.\n   */const GenerateWordArray=useCallback(()=>{if(!initWords||initWords.length===0)return;GameOver();const currentIndex=callCount%initWords.length;const fixedWord=initWords[currentIndex];const fixedTextValue=fixedWord.text;const fixedImageValue=fixedWord.image;const fixedAudioValue=fixedWord.audio;let x;if(month===3){x=6;}else if(month===6){x=3;}else{x=0;}const newInitWords=initWords.filter((_,index)=>index!==currentIndex);const shuffleWords=[...newInitWords].concat(new Array(x).fill({text:\"none\",image:inactivePanel,audio:\"\"})).sort(()=>Math.random()-0.5);const remainingWords=shuffleWords.slice(0,8);const grid=[fixedWord,...remainingWords].sort(()=>Math.random()-0.5);setCallCount(prevCount=>prevCount+1);setBoxes(grid);setDisplayText(fixedTextValue);setDisplayImage(fixedImageValue);setDisplayAudio(fixedAudioValue);},[callCount,initWords,month,GameOver]);// Purpose:Update words to be fillled in he grid  based on the month after randomizing the words, initiallize round Count\nuseEffect(()=>{let words=[];switch(month){case 3:words=WORD_INFO.slice(0,3);break;case 6:words=WORD_INFO.slice(0,6);break;case 9:words=WORD_INFO.slice(0,9);break;case 12:words=WORD_INFO.slice(0,12);break;case 15:words=WORD_INFO.slice(0,15);break;case 18:words=WORD_INFO.slice(0,18);break;case 20:words=WORD_INFO;break;default:words=WORD_INFO.slice(0,9);}const randomizeWords=[...words].sort(()=>Math.random()-0.5);setCallCount(0);setSuccessCount(0);setInitWords(randomizeWords);setIsInitialized(false);},[month]);// Generate the initial grid and update display text after `initWords` is updated\nuseEffect(()=>{if(initWords.length>0&&!isInitialized){setIsInitialized(true);GenerateWordArray();setRoundDisplay(callCount+\"/\"+month);}},[initWords,isInitialized,GenerateWordArray,setRoundDisplay,month,callCount]);/**\n   * HandleSelection\n   * \n   * Purpose: PBoolean to determine if the selected image corresponds to word displayed and give response accordingly. \n   * Also automatically moves to next round after display of result.\n   * \n   * paramaters\n   * selectedImages: image selected by the user\n   */const HandleSelection=selectedImage=>{if(selectedImage===displayImage){new Audio(congratulationsAudio).play();GenerateWordArray();setRoundDisplay(callCount+\"/\"+month);setSuccessCount(prevCount=>prevCount+1);}else{new Audio(tryAgainAudio).play();GenerateWordArray();setRoundDisplay(callCount+\"/\"+month);}};/**\n   * playAudio\n   * \n   * Purpose: Plays the audio associated with the currently displayed word.\n   */const PlayAudio=()=>{if(displayAudio){new Audio(displayAudio).play();}};/**\n   * newGame\n   * \n   * Purpose: Resets the game state to start a new game.\n   */const NewGame=()=>{setCallCount(0);setSuccessCount(0);const reshuffledWords=[...initWords].sort(()=>Math.random()-0.5);setInitWords(reshuffledWords);setIsInitialized(false);setGameEnd(false);};/**\n * Purpose: returns the display of the grid along with question word based on mobile or Desktop view. \n * Also displays final score after end of a game.\n */return/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsx(MobileView,{gameEnd:gameEnd,successCount:successCount,onNewGame:NewGame,onPlayAudio:PlayAudio,displayText:displayText,roundDisplay:roundDisplay,boxes:boxes,onHandleSelection:HandleSelection}),/*#__PURE__*/_jsx(DesktopView,{gameEnd:gameEnd,successCount:successCount,onNewGame:NewGame,onPlayAudio:PlayAudio,displayText:displayText,roundDisplay:roundDisplay,boxes:boxes,onHandleSelection:HandleSelection})]});}export default WordDistribution;","map":{"version":3,"names":["React","useEffect","useState","useCallback","WORD_INFO","MobileView","DesktopView","tryAgainAudio","congratulationsAudio","inactivePanel","jsx","_jsx","jsxs","_jsxs","WordDistribution","_ref","month","callCount","setCallCount","boxes","setBoxes","initWords","setInitWords","isInitialized","setIsInitialized","displayText","setDisplayText","displayAudio","setDisplayAudio","displayImage","setDisplayImage","roundDisplay","setRoundDisplay","successCount","setSuccessCount","gameEnd","setGameEnd","GameOver","GenerateWordArray","length","currentIndex","fixedWord","fixedTextValue","text","fixedImageValue","image","fixedAudioValue","audio","x","newInitWords","filter","_","index","shuffleWords","concat","Array","fill","sort","Math","random","remainingWords","slice","grid","prevCount","words","randomizeWords","HandleSelection","selectedImage","Audio","play","PlayAudio","NewGame","reshuffledWords","children","onNewGame","onPlayAudio","onHandleSelection"],"sources":["C:/Users/tatas/OneDrive/University/Fall 2025/CSCI 3428/LLA/src/components/GridLayout/WordDistribution.jsx"],"sourcesContent":["/**\n * WordDistribution.jsx\n * \n * Purpose: Implementation of grid and question word\n *          The game dynamically updates based on the selected month, providing audio feedback\n *          and visual rewards. Users earn stars for correct matches and can reset the game.\n * \n * Author(s): Preksha Joon, Aaron Gonsalves\n * Assisted by: ChatGPT (Documentation assistance + Fixing Roadblocks)\n * \n * COTS Used:\n * - React: JavaScript library for building user interfaces. (https://reactjs.org/)\n * - Tailwind CSS: Utility-first CSS framework for styling. (https://tailwindcss.com/)\n * - Local assets for images (Michael's efforts and Microsoft Designer) and audio files.\n */\n\n\n\nimport React, { useEffect, useState, useCallback } from \"react\";\nimport { WORD_INFO } from \"../WordBank\";\nimport MobileView from \"./MobileView\";\nimport DesktopView from \"./DesktopView\";\nimport tryAgainAudio from \"../audio/tryagain.mp3\";\nimport congratulationsAudio from \"../audio/congratulatory.mp3\";\nimport inactivePanel from \"../images/colour.jpg\";\n\n/**\n * WordDistribution Component\n * \n * Purpose: Renders the game interface where users match words to images based on the selected month.\n * \n * Parameters:\n * - month: (number) The selected number corresponding to the month based on the words of the month, \n * which determines the set of words and game logic.\n */\nfunction WordDistribution({ month }) {\n  const [callCount, setCallCount] = useState(0);\n  const [boxes, setBoxes] = useState([]);\n  const [initWords, setInitWords] = useState([]);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [displayText, setDisplayText] = useState(\"\");\n  const [displayAudio, setDisplayAudio] = useState(\"\");\n  const [displayImage, setDisplayImage] = useState(\"\");\n  const [roundDisplay, setRoundDisplay] = useState(callCount + \"/\" + month);\n  const [successCount, setSuccessCount] = useState(0);\n  const [gameEnd, setGameEnd] = useState(false);\n\n  /**\n   * gameOver\n   * \n   * Purpose: Determines if the game has ended based on the number of rounds played.\n   */\n  const GameOver = useCallback(() => {\n    if (month < 9) {\n      if ((month === 3 && callCount === 3) || (month === 6 && callCount === 6)) {\n        setGameEnd(true);\n      }\n    } else {\n      if (callCount === month) setGameEnd(true);\n    }\n  }, [month, callCount]);\n\n  /**\n   * generateWordArray\n   * \n   * Purpose: Generates a new word array for the grid, shuffling words and preparing the game state for the next round. \n   * Also, selects the question word for each round, and updates it on display.\n   */\n  const GenerateWordArray = useCallback(() => {\n    if (!initWords || initWords.length === 0) return;\n    GameOver();\n\n    const currentIndex = callCount % initWords.length;\n    const fixedWord = initWords[currentIndex];\n    const fixedTextValue = fixedWord.text;\n    const fixedImageValue = fixedWord.image;\n    const fixedAudioValue = fixedWord.audio;\n\n    let x;\n    if (month === 3) {\n      x = 6;\n    } else if (month === 6) {\n      x = 3;\n    } else {\n      x = 0;\n    }\n\n    const newInitWords = initWords.filter((_, index) => index !== currentIndex);\n    const shuffleWords = [...newInitWords]\n      .concat(\n        new Array(x).fill({\n          text: \"none\",\n          image: inactivePanel,\n          audio: \"\",\n        })\n      )\n      .sort(() => Math.random() - 0.5);\n\n    const remainingWords = shuffleWords.slice(0, 8);\n    const grid = [fixedWord, ...remainingWords].sort(() => Math.random() - 0.5);\n\n    setCallCount((prevCount) => prevCount + 1);\n    setBoxes(grid);\n    setDisplayText(fixedTextValue);\n    setDisplayImage(fixedImageValue);\n    setDisplayAudio(fixedAudioValue);\n  }, [callCount, initWords, month, GameOver]);\n\n  // Purpose:Update words to be fillled in he grid  based on the month after randomizing the words, initiallize round Count\n  useEffect(() => {\n    let words = [];\n    switch (month) {\n      case 3:\n        words = WORD_INFO.slice(0, 3);\n        break;\n      case 6:\n        words = WORD_INFO.slice(0, 6);\n        break;\n      case 9:\n        words = WORD_INFO.slice(0, 9);\n        break;\n      case 12:\n        words = WORD_INFO.slice(0, 12);\n        break;\n      case 15:\n        words = WORD_INFO.slice(0, 15);\n        break;\n      case 18:\n        words = WORD_INFO.slice(0, 18);\n        break;\n      case 20:\n        words = WORD_INFO;\n        break;\n      default:\n        words = WORD_INFO.slice(0, 9);\n    }\n    const randomizeWords = [...words].sort(() => Math.random() - 0.5);\n    setCallCount(0);\n    setSuccessCount(0);\n    setInitWords(randomizeWords);\n    setIsInitialized(false);\n  }, [month]);\n\n  // Generate the initial grid and update display text after `initWords` is updated\n  useEffect(() => {\n    if (initWords.length > 0 && !isInitialized) {\n      setIsInitialized(true);\n      GenerateWordArray();\n      setRoundDisplay(callCount  + \"/\" + month);\n    }\n  }, [initWords, isInitialized, GenerateWordArray, setRoundDisplay, month, callCount]);\n\n  /**\n   * HandleSelection\n   * \n   * Purpose: PBoolean to determine if the selected image corresponds to word displayed and give response accordingly. \n   * Also automatically moves to next round after display of result.\n   * \n   * paramaters\n   * selectedImages: image selected by the user\n   */\n  const HandleSelection = (selectedImage) => {\n    if (selectedImage === displayImage) {\n      new Audio(congratulationsAudio).play();\n      GenerateWordArray();\n      setRoundDisplay((callCount ) + \"/\" + month);\n      setSuccessCount((prevCount) => prevCount + 1);\n    } else {\n      new Audio(tryAgainAudio).play();\n      GenerateWordArray();\n      setRoundDisplay((callCount ) + \"/\" + month);\n    }\n  };\n\n  /**\n   * playAudio\n   * \n   * Purpose: Plays the audio associated with the currently displayed word.\n   */\n  const PlayAudio = () => {\n    if (displayAudio) {\n      new Audio(displayAudio).play();\n    }\n  };\n\n  /**\n   * newGame\n   * \n   * Purpose: Resets the game state to start a new game.\n   */\n  const NewGame = () => {\n    setCallCount(0);\n    setSuccessCount(0);\n    const reshuffledWords = [...initWords].sort(() => Math.random() - 0.5);\n    setInitWords(reshuffledWords);\n    setIsInitialized(false);\n    setGameEnd(false);\n  };\n/**\n * Purpose: returns the display of the grid along with question word based on mobile or Desktop view. \n * Also displays final score after end of a game.\n */\n  return (\n    <div>\n      <MobileView\n        gameEnd={gameEnd}\n        successCount={successCount}\n        onNewGame={NewGame}\n        onPlayAudio={PlayAudio}\n        displayText={displayText}\n        roundDisplay={roundDisplay}\n        boxes={boxes}\n        onHandleSelection={HandleSelection}\n      />\n      <DesktopView\n        gameEnd={gameEnd}\n        successCount={successCount}\n        onNewGame={NewGame}\n        onPlayAudio={PlayAudio}\n        displayText={displayText}\n        roundDisplay={roundDisplay}\n        boxes={boxes}\n        onHandleSelection={HandleSelection}\n      />\n    </div>\n  );\n}\n\nexport default WordDistribution;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}